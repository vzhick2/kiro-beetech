# AI Development Rules for KIRO-BEETECH Inventory System

## Project Context
- Internal business inventory management system (not public/commercial)
- Next.js 15.4.1 with React 19.1.0, TypeScript 5.8.3, Tailwind CSS 4.1.11
- Supabase for database and authentication
- Small business workflows with flexible data entry patterns

## AI Workflow Rules
- **MCP-First Approach**: Use MCP tools for deep analysis, database operations, and rapid commits
- **Database Investigation**: Use Supabase MCP to understand schema, test queries, and validate data before coding
- **Rapid Iteration**: Use GitHub MCP for fast commits when implementing multiple related changes
- ALWAYS ask "Should I implement this?" before making file changes
- Provide options first, then wait for explicit approval
- Follow docs/requirements.md for feature specifications
- Use docs/data-model.md for database schema (verify with Supabase MCP when uncertain)
- Reference docs/technical-design.md for architecture decisions
- Use docs/development-guide.md for development standards

## Autonomous Processing Rules
### Autonomous Actions (No Permission Needed)
- Fix linting and TypeScript errors
- Format code with Prettier
- Update documentation for completed tasks
- Use existing utility functions from src/lib/utils
- Follow established naming conventions
- Update tasks.md with âœ… and completion date when marking tasks complete
- Update CHANGELOG.md with version and description when adding features

### Permission Required Actions
- Add new features or components
- Modify database schema
- Change business logic
- Update dependencies
- Create new utility functions
- Create scripts (.ps1, .sh, .bat files)
- Create documentation files (.md files)
- Create test components or example code
- Update data-model.md and api-documentation.md when modifying database schema
- Update technical-design.md when changing architecture decisions

## Error Prevention Rules
- Check existing implementations before creating new ones
- Use existing utility functions from src/lib/utils
- Follow established naming conventions
- Verify imports and dependencies before adding
- Check for duplicate functionality
- Ensure all documentation is aligned before finalizing changes

## Code Standards (AI Must Follow)
- Use TypeScript strict mode with explicit return types
- Prefer interfaces over types for object shapes
- Write functional components with TypeScript interfaces (avoid React.FC)
- Use server components by default, 'use client' only when necessary
- Use Tailwind CSS for ALL styling (no CSS-in-JS)
- Implement early returns for better readability
- Use descriptive variable names with auxiliary verbs (isLoading, hasError)

## AI Code Quality Standards
- Use Zod validation for runtime type safety
- Implement exhaustive branch checking with ensureExhaustive patterns
- Use efficient TypeScript checking with --skipLibCheck for development
- Prioritize type safety over convenience

## Business Logic Requirements
- Support negative inventory with warnings (real-world flexibility)
- Implement mutable transaction logs with editable records and timestamps
- Add cycle count alerts for proactive inventory management
- Design mobile-first for workshop operations
- Create direct-edit workflows for quick updates
- Support back-dating for corrections

## File Structure Patterns
- `src/app/` - Next.js 15 App Router pages
- `src/components/` - Reusable UI components
- `src/lib/` - Utilities, Supabase client, business logic
- `src/hooks/` - Custom React hooks
- `src/types/` - TypeScript definitions
- `docs/` - Project specifications

## Debugging and Analysis Patterns
- **MCP-Powered Debugging**: Use Supabase MCP for real-time database analysis and GitHub MCP for codebase search
- **Database Issues**: Query database directly via MCP to understand data state and validate business logic
- **Code Analysis**: Use GitHub MCP to search for similar implementations, usage patterns, and related functionality
- **Performance Investigation**: Use Supabase MCP to analyze query performance, check indexes, review security advisors
- **Integration Testing**: Use MCP tools to create test data, validate workflows, and verify end-to-end functionality
- Prioritize error handling at function beginnings
- Use guard clauses for preconditions
- Implement Zod validation for runtime type checking
- Create user-friendly error messages with clear actions

## State Management Patterns
- Use TanStack Query for server state and caching
- Use Zustand for global UI state only
- Use URL params for view state
- Use server actions for mutations

## Database Patterns
- Use Supabase client for database operations
- Implement row-level security policies
- Use PostgreSQL RPCs for atomic operations
- Use display ID pattern for user-facing references

## MCP (Model Context Protocol) Capabilities
The project has comprehensive MCP integration for enhanced development workflow:

### Supabase MCP Server
- **Project Access**: `jjpklpivpvywagmjjwpu` (full read/write access, project-scoped)
- **Database Operations**: Direct SQL queries, table inspection, data modification, schema analysis
- **Development Operations**: Run migrations, deploy Edge Functions, generate TypeScript types
- **Real-time Development**: Live database debugging, data analysis, and instant modifications
- **Advanced Features**: Security advisor checks, logs analysis, branch operations for development databases

### GitHub MCP Server  
- **Repository Access**: `vzhick2/kiro-beetech` (full repo, workflow, read:org, user scopes)
- **Fast Commits**: Single API call commits with multiple files (~85% faster than traditional git)
- **Repository Operations**: Create/update files, manage branches, handle pull requests, search code
- **Issue Management**: Create issues, manage discussions, handle project workflows
- **Deployment**: Direct push to main branch, atomic commits, batch file operations

### MCP Development Workflow
- **Database-First Development**: Use Supabase MCP to explore schema, test queries, validate data integrity
- **Rapid Prototyping**: Direct database modifications for testing business logic and data flows  
- **Fast Iteration**: GitHub MCP for instant commits, eliminating traditional git workflow delays
- **Integrated Debugging**: Real-time database inspection and modification during development
- **Production Safety**: Use Supabase branch operations for safe schema testing before production deployment

### MCP Usage Examples
- **Database**: "Show me all tables", "Add test supplier", "Check cycle count alerts", "Deploy this migration"
- **GitHub**: "Commit these changes with message X", "Create branch for feature Y", "Search for function Z in codebase"
- **Analysis**: "Analyze current inventory levels", "Show recent purchase patterns", "Validate database integrity"

## AI Development Commands
- Use `pnpm ai:validate` for fast validation (type-check, lint, format)
- Use `pnpm ai:validate:full` for full type-check for production builds
- Use `pnpm ai:fix` for auto-fixing common issues
- Use `pnpm ai:type-check` for fast type-check only
- Use `pnpm build` for production build
- Use `pnpm supabase:types` for updating database types

## Git Workflow Rules
- **PREFER GitHub MCP** for commits when multiple files need updating (~85% faster than traditional git)
- **Use GitHub MCP**: `mcp_github_push_files` for batch commits with descriptive messages
- **Fallback to Traditional Git**: Only when GitHub MCP is unavailable or for single-file changes
- **Traditional Git**: Use combined commands: `git add . && git commit -m "message" && git push origin main`
- **Commit Messages**: Descriptive, present-tense explaining what changed and why with technical details
- **Batch Operations**: Group related changes into single atomic commits via GitHub MCP
- **Branch Strategy**: Direct commits to main branch for internal development (no PR overhead)

## Development Server Rules
- NEVER suggest or ask to run `pnpm dev` or start development servers
- User manages development server independently
- Focus on code implementation and testing via build validation
- Use `pnpm build` to verify functionality instead of running servers

## AI Behavior Rules
- This is an internal business tool prioritizing flexibility over rigid constraints
- Focus on real-world workflows and forgiving data entry
- Implement business logic that matches actual workshop operations
- Prioritize user experience over technical perfection 

## Commit Message Standards
- Use descriptive, present-tense messages
- Include what was changed and why
- Avoid generic messages like "fix bug" or "update code"